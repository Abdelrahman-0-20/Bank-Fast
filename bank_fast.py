# -*- coding: utf-8 -*-
"""Bank-Fast.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yoN0rKkUjJngWDhMWiT_GO1nRxt9RGxr

# Import Necessary Libraries
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split

from sklearn.linear_model import LogisticRegression

"""# Load the Data"""

df = pd.read_excel('/content/cleaned_bank_data_copy.xlsx')

"""# Data Inspection"""

print(df.head())

"""# Get summary statistics

"""

print(df.describe())

"""# Check the data types

"""

print(df.info())

"""# Handle Missing Values"""

print("Missing values per column:\n", df.isnull().sum())

"""# No missing Values

# Replace 'unknown' with NaN
"""

df.replace('unknown', np.nan, inplace=True)

print("Missing values after cleaning:\n", df.isnull().sum())

"""# Check for duplicates

"""

print("Number of duplicates:", df.duplicated().sum())

"""# Remove duplicates if they exist

"""

df.drop_duplicates(inplace=True)

"""# Remove rows with negative balances"""

df = df[df['balance'] >= 0]

"""# Check for negative durations and handleit"""

df = df[df['duration'] >= 0]

"""# Drop unused Columns"""

columns_to_drop = ['pdays', 'campaign', 'previous', 'poutcome' , 'y']
# Add errors='ignore' to prevent the KeyError if a column is not found
df.drop(columns=columns_to_drop, inplace=True, errors='ignore')

print(df.head())

"""# Create a Copy of the Cleaned DataFrame"""

cleaned_df_copy = df.copy()

print(cleaned_df_copy.head())

"""# Visualize Data

# Analysis of Question 1: How does age correlate with account balance?

here is a positive trend indicating that older individuals tend to have higher account balances.
Younger clients generally have lower account balances, with most values clustered in the lower range.

# plot of Age vs Balance
"""

bins = [0, 20, 30, 40, 50, 60, 70, 80, 90, 100]
labels = ['0-20', '21-30', '31-40', '41-50', '51-60', '61-70', '71-80', '81-90', '91-100']
df['age_group'] = pd.cut(df['age'], bins=bins, labels=labels, right=False)

# Calculate average balance for each age group
age_balance = df.groupby('age_group')['balance'].mean().reset_index()

# Plotting the bar chart
plt.figure(figsize=(10, 6))
plt.bar(age_balance['age_group'], age_balance['balance'], color='skyblue')
plt.title('Average Account Balance by Age Group', fontsize=16)
plt.xlabel('Age Group', fontsize=14)
plt.ylabel('Average Account Balance', fontsize=14)
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.show()

"""# Analysis Question 2: Is there a significant difference in balances between different job types?

Yes There Are a Difference

Management/Entrepreneurs tend to have significantly higher savings, reflecting higher earnings.

Students/Unemployed show minimal balances, indicating financial constraints.
"""

# Set the aesthetic style of the plots
sns.set(style="whitegrid")

# Visualization: Violin plot for Balance by Job Type
plt.figure(figsize=(12, 8))
sns.violinplot(x='job', y='balance', data=df, inner='quartile')
plt.title('Distribution of Account Balances by Job Type', fontsize=16)
plt.xlabel('Job Type', fontsize=14)
plt.ylabel('Account Balance', fontsize=14)
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.show()

"""#Analysis Question 4 : Average Balance by Job Type"""

average_balance = df.groupby('job')['balance'].mean().reset_index()

# Create a bar chart for average balance by job type
plt.figure(figsize=(12, 6))
sns.barplot(x='balance', y='job', data=average_balance.sort_values('balance', ascending=False), palette='viridis')
plt.title('Average Balance by Job Type', fontsize=16, fontweight='bold')
plt.xlabel('Average Balance', fontsize=14)
plt.ylabel('Job Type', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""# Analysis Question 5 : Marital Status Distribution"""

plt.figure(figsize=(8, 5))
sns.countplot(data=df, x='marital', order=df['marital'].value_counts().index)
plt.title('Distribution of Marital Status')
plt.xlabel('Marital Status')
plt.ylabel('Count')
plt.show()

"""#Question 6 : What is the relationship between loan status and call duration?

There is no big differences to haveing A call affecting on your loan
"""

# Group by loan status and calculate the average call duration
average_duration = df.groupby('loan')['duration'].mean().reset_index()

# Create a bar chart for average call duration
plt.figure(figsize=(10, 6))
sns.barplot(x='loan', y='duration', data=average_duration, palette='pastel')
plt.title('Average Call Duration by Loan Status', fontsize=16, fontweight='bold')
plt.xlabel('Loan Status', fontsize=14)
plt.ylabel('Average Call Duration (seconds)', fontsize=14)
plt.xticks(rotation=0, fontsize=12)
plt.yticks(fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""#Analysis Questin 7 : How does the education level impact the likelihood of having a higher balance?

Tertiary Education has the highest average account balance .

Secondary Education has a lower average balance .

Primary Education has the lowest average balance, appearing to be negative , which could indicate debt or overdrawn accounts.
"""

# Calculate average balance and its standard deviation for each education level
average_balance = df.groupby('education')['balance'].agg(['mean', 'std']).reset_index()

plt.figure(figsize=(10, 6))
plt.bar(average_balance['education'], average_balance['mean'], yerr=average_balance['std'], color='skyblue', capsize=5)
plt.title('Average Account Balance by Education Level', fontsize=16)
plt.xlabel('Education Level', fontsize=14)
plt.ylabel('Average Account Balance', fontsize=14)
plt.xticks(rotation=0)
plt.grid(axis='y')
plt.show()

"""#Analysis Question 8 : What is the relationship between a clientâ€™s job type and the uptake of loans?

there's different job types are associated with loan statuses
"""

loan_distribution = pd.crosstab(df['job'], df['loan'])

# Now, create the stacked bar chart using the contingency table
plt.figure(figsize=(14, 8))
colors = ['#ff9999', '#66b3ff']  # Color palette for the Loan Status
loan_distribution.plot(kind='bar', stacked=True, color=colors, ax=plt.gca())

# Enhancing titles and labels
plt.title('Loan Distribution by Job Type', fontsize=18, fontweight='bold')
plt.xlabel('Job Type', fontsize=14, fontweight='bold')
plt.ylabel('Number of Customers', fontsize=14, fontweight='bold')
plt.xticks(rotation=45, fontsize=12)  # Rotate x-axis labels for better readability
plt.yticks(fontsize=12)  # Increase font size of y-axis ticks
plt.legend(title='Loan Status', labels=['No Loan', 'Loan'], fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Add gridlines for better readability

# Adjust layout for better fit
plt.tight_layout()
plt.show()

"""# Marital Status vs. Loan Uptake

The most percentage of the married clients take a loan
"""

plt.figure(figsize=(10, 6))
marital_housing_crosstab = pd.crosstab(df['marital'], df['housing'])
marital_housing_crosstab.plot(kind='bar', stacked=True, figsize=(10, 6), colormap='viridis')
plt.title('Housing Loan Status by Marital Status', fontsize=16)
plt.xlabel('Marital Status', fontsize=14)
plt.ylabel('Number of Clients', fontsize=14)
plt.xticks(rotation=0)
plt.legend(title='Housing Loan', loc='upper right')
plt.tight_layout()
plt.show()

"""# Marital Status vs. Personal Loan

The most of the subscriptions Are from married people

--> most focus on families offers
"""

plt.figure(figsize=(10, 6))
marital_personal_crosstab = pd.crosstab(df['marital'], df['loan'])
marital_personal_crosstab.plot(kind='bar', stacked=True, figsize=(10, 6), colormap='plasma')
plt.title('Personal Loan Status by Marital Status', fontsize=16)
plt.xlabel('Marital Status', fontsize=14)
plt.ylabel('Number of Clients', fontsize=14)
plt.xticks(rotation=0)
plt.legend(title='Personal Loan', loc='upper right')
plt.tight_layout()
plt.show()

"""# Distribution of Clients by Month of Last Contact"""

month_counts = df['month'].value_counts().reindex([
    'jan', 'feb', 'mar', 'apr', 'may', 'jun',
    'jul', 'aug', 'sep', 'oct', 'nov', 'dec'
], fill_value=0)

plt.figure(figsize=(12, 7))
sns.barplot(x=month_counts.index, y=month_counts.values, palette='mako')
plt.title('Number of Clients by Month of Last Contact', fontsize=16)
plt.xlabel('Month', fontsize=14)
plt.ylabel('Number of Clients', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""# Correlation Heatmap of Numerical Features"""

# Select only numerical columns for correlation calculation
numerical_df = df[['age', 'balance', 'day', 'duration']]
correlation_matrix = numerical_df.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Heatmap of Numerical Features', fontsize=16)
plt.show()

"""# Pie Chart for Housing Loan Statu

pie chart clearly shows the proportion of clients who have a housing loan
see the prevalence of housing loans
"""

plt.figure(figsize=(8, 8)) # Set the figure size for a good-looking pie chart

housing_counts = df['housing'].value_counts(dropna=True)

# Define custom colors for 'no' and 'yes' to make them distinct.
colors = ['#ff9992', '#66b3ee'] # Example colors: light red for 'no', light blue for 'yes'

# Create the pie chart, similar to the marital status chart.
plt.pie(housing_counts, labels=housing_counts.index, colors=colors, autopct='%1.1f%%', startangle=90,
        pctdistance=0.85, wedgeprops=dict(width=0.3))

# Set the title of the chart.
plt.title('Distribution of Housing Loan Status', fontsize=16)

# 'axis('equal')' ensures that the pie chart is drawn as a perfect circle.
plt.axis('equal')

# Adjust layout to prevent labels/titles from overlapping.
plt.tight_layout()

# Display the plot.
plt.show()

# --- Visualization 3: Line Chart (Average Contact Duration by Month) ---
# Benefit/Meaning: A line chart is excellent for showing trends over an ordered category like months.
# This chart displays the average duration of client contacts for each month.
# It helps identify if there are seasonal patterns in how long interactions typically last,
# which can be useful for resource planning or understanding campaign impacts over time.
print("\n--- Plot 3: Line Chart (Average Contact Duration by Month) ---")

# Define the order of months for correct plotting
month_order = ['jan', 'feb', 'mar', 'apr', 'may', 'jun',
               'jul', 'aug', 'sep', 'oct', 'nov', 'dec']

# Calculate the average duration for each month
# Use the existing cleaned dataframe 'df' instead of the undefined 'df_cleaned_for_line'
average_duration_by_month = df.groupby('month')['duration'].mean().reindex(month_order)

plt.figure(figsize=(12, 7))
sns.lineplot(x=average_duration_by_month.index, y=average_duration_by_month.values,
             marker='o', linestyle='-', color='teal', linewidth=2, markersize=8)
plt.title('Average Contact Duration by Month', fontsize=16)
plt.xlabel('Month', fontsize=14)
plt.ylabel('Average Contact Duration (seconds)', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.7)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()





